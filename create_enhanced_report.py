"""
Enhanced Markdown Report Generator for JIRA Issue Data Quality Checker

This creates a more polished markdown report with better formatting,
table of contents, and improved readability.
"""

import re
from datetime import datetime
from typing import Dict, List, Any, Optional


def create_enhanced_markdown_report(console_text: str) -> str:
    """
    Create an enhanced markdown report with better formatting and navigation
    """
    lines = console_text.split('\n')
    
    # Initialize report sections
    sections = {
        'authentication': '',
        'rules': '',
        'stories': '',
        'tasks': '',
        'bugs': '', 
        'epics': '',
        'subtasks': '',
        'labels': '',
        'summary': ''
    }
    
    # Parse the console output
    current_section = None
    issue_count = 0
    violation_count = 0
    
    i = 0
    while i < len(lines):
        line = lines[i].strip()
        
        if not line:
            i += 1
            continue
            
        # Detect sections
        if '[AUTH]' in line and 'Logged in as:' in line:
            user_name = line.split('Logged in as:')[1].strip()
            email = ""
            if i + 1 < len(lines) and 'Email:' in lines[i + 1]:
                email = lines[i + 1].split('Email:')[1].strip()
                i += 1
            sections['authentication'] = format_auth_section(user_name, email)
            
        elif '[RULES]' in line and 'Rule Engine initialized:' in line:
            sections['rules'] = parse_rules_section(lines, i)
            
        elif '[CHECK] CHECKING STORY ISSUES' in line:
            current_section = 'stories'
            sections['stories'] = "## ğŸ“– Story Issues\n\n"
            
        elif '[CHECK] CHECKING TASK ISSUES' in line:
            current_section = 'tasks'
            sections['tasks'] = "## âœ… Task Issues\n\n"
            
        elif '[CHECK] CHECKING BUG ISSUES' in line:
            current_section = 'bugs'
            sections['bugs'] = "## ğŸ› Bug Issues\n\n"
            
        elif '[CHECK] CHECKING EPIC ISSUES' in line:
            current_section = 'epics'
            sections['epics'] = "## ğŸ¯ Epic Issues\n\n"
            
        elif '[CHECK] CHECKING SUB-TASK ISSUES' in line:
            current_section = 'subtasks'
            sections['subtasks'] = "## ğŸ”§ Sub-task Issues\n\n"
            
        elif '[REPORT] LABEL USAGE REPORT' in line:
            current_section = 'labels'
            sections['labels'] = parse_label_section(lines, i)
            
        elif current_section and re.match(r'^\s*\d+\.\s+\w+:\s+\w+-\d+', line):
            # Parse individual issue
            issue_data = parse_issue_details(lines, i)
            if issue_data:
                sections[current_section] += format_issue_markdown(issue_data)
                issue_count += 1
        
        i += 1
    
    # Build the final report
    timestamp = datetime.now().strftime("%Y-%m-%d %H:%M:%S")
    
    report = f"""# ğŸ“Š JIRA Issue Data Quality Report

**Generated:** {timestamp}  
**Project:** AP (TM Forum JIRA)  
**Issues Analyzed:** {issue_count}

---

## ğŸ“‹ Table of Contents

1. [ğŸ” Authentication Status](#-authentication-status)
2. [âš™ï¸ Rule Engine Configuration](#ï¸-rule-engine-configuration)
3. [ğŸ“– Story Issues](#-story-issues)
4. [âœ… Task Issues](#-task-issues)
5. [ğŸ› Bug Issues](#-bug-issues)
6. [ğŸ¯ Epic Issues](#-epic-issues)
7. [ğŸ”§ Sub-task Issues](#-sub-task-issues)
8. [ğŸ·ï¸ Label Usage Report](#ï¸-label-usage-report)
9. [ğŸ“ˆ Summary & Insights](#-summary--insights)

---

## ğŸ” Authentication Status

{sections['authentication']}

## âš™ï¸ Rule Engine Configuration

{sections['rules']}

{sections['stories']}

{sections['tasks']}

{sections['bugs']}

{sections['epics']}

{sections['subtasks']}

## ğŸ·ï¸ Label Usage Report

{sections['labels']}

## ğŸ“ˆ Summary & Insights

{generate_summary_section(console_text)}

---

*Report generated by JIRA Issue Data Quality Checker*  
*Last updated: {timestamp}*  
*ğŸ”— [View in JIRA](https://projects.tmforum.org/jira/projects/AP)*
"""
    
    return report


def format_auth_section(user_name: str, email: str) -> str:
    """Format authentication section"""
    return f"""âœ… **Successfully authenticated with TM Forum JIRA**

| Field | Value |
|-------|-------|
| **User** | {user_name} |
| **Email** | {email} |
| **Status** | âœ… Active |

"""


def parse_rules_section(lines: List[str], start_idx: int) -> str:
    """Parse the rules section"""
    rules_text = "âœ… **Rule Engine Successfully Initialized**\n\n"
    
    # Look for rule summary
    for i in range(start_idx, min(start_idx + 15, len(lines))):
        line = lines[i].strip()
        if '/' in line and 'rules enabled' in line:
            match = re.search(r'(\d+)/(\d+) rules enabled', line)
            if match:
                enabled, total = match.groups()
                rules_text += f"**Rules Status:** {enabled}/{total} rules enabled\n\n"
        elif line.startswith('- ') and ':' in line:
            category_match = re.search(r'- ([^:]+): (\d+) rules', line)
            if category_match:
                category, count = category_match.groups()
                rules_text += f"- **{category.title()}:** {count} rules\n"
    
    return rules_text + "\n"


def parse_issue_details(lines: List[str], start_idx: int) -> Optional[Dict[str, Any]]:
    """Parse individual issue details"""
    issue_data = {}
    
    # Parse issue header
    header_line = lines[start_idx].strip()
    issue_match = re.match(r'^\s*(\d+)\.\s+(\w+):\s+(\w+-\d+)', header_line)
    if not issue_match:
        return None
        
    issue_data['number'] = issue_match.group(1)
    issue_data['type'] = issue_match.group(2)
    issue_data['key'] = issue_match.group(3)
    
    # Parse subsequent lines
    i = start_idx + 1
    violations = []
    passes = []
    tmf_apis = []
    
    while i < len(lines) and i < start_idx + 50:  # Look ahead max 50 lines
        line = lines[i].strip()
        
        if re.match(r'^\d+\.\s+\w+:', line):  # Next issue
            break
            
        if line.startswith('Title:'):
            issue_data['title'] = line.replace('Title:', '').strip()
        elif line.startswith('Status:'):
            issue_data['status'] = line.replace('Status:', '').strip()
        elif line.startswith('Assignee:'):
            issue_data['assignee'] = line.replace('Assignee:', '').strip()
        elif line.startswith('URL:'):
            issue_data['url'] = line.replace('URL:', '').strip()
        elif line.startswith('[TMF]') and 'TMF APIs Referenced:' in line:
            # Parse TMF APIs
            j = i + 1
            while j < len(lines) and lines[j].strip().startswith('- '):
                api_line = lines[j].strip()[2:]  # Remove "- "
                tmf_apis.append(api_line)
                j += 1
            i = j - 1
        elif line.startswith('[WARNING]') or line.startswith('[ERROR]') or line.startswith('[CRITICAL]'):
            violations.append(line)
        elif line.startswith('[PASS]'):
            passes.append(line.replace('[PASS]', '').strip())
        
        i += 1
    
    issue_data['violations'] = violations
    issue_data['passes'] = passes
    issue_data['tmf_apis'] = tmf_apis
    
    return issue_data


def format_issue_markdown(issue_data: Dict[str, Any]) -> str:
    """Format issue data as markdown"""
    if not issue_data:
        return ""
    
    # Status emoji mapping
    status_emoji = {
        'In Progress': 'ğŸ”„',
        'To Do': 'ğŸ“‹',
        'Done': 'âœ…',
        'Closed': 'ğŸ”’',
        'Open': 'ğŸ“‚'
    }
    
    status = issue_data.get('status', 'Unknown')
    emoji = status_emoji.get(status, 'â“')
    
    markdown = f"""### {issue_data.get('number', '?')}. {emoji} {issue_data.get('key', 'Unknown')}

**ğŸ“ Title:** {issue_data.get('title', 'No title')}  
**ğŸ“Š Status:** {status}  
**ğŸ‘¤ Assignee:** {issue_data.get('assignee', 'Unassigned')}  
**ğŸ”— URL:** [{issue_data.get('key', 'Link')}]({issue_data.get('url', '#')})

"""
    
    # Add TMF APIs if present
    if issue_data.get('tmf_apis'):
        markdown += "**ğŸ”Œ TMF APIs Referenced:**\n"
        for api in issue_data['tmf_apis']:
            markdown += f"- {api}\n"
        markdown += "\n"
    
    # Add violations
    violations = issue_data.get('violations', [])
    if violations:
        markdown += "**âš ï¸ Rule Violations:**\n"
        for violation in violations:
            severity_emoji = {
                '[WARNING]': 'ğŸŸ¡',
                '[ERROR]': 'ğŸŸ ', 
                '[CRITICAL]': 'ğŸ”´'
            }
            for severity, emoji in severity_emoji.items():
                if violation.startswith(severity):
                    clean_violation = violation.replace(severity, '').strip()
                    markdown += f"- {emoji} {clean_violation}\n"
                    break
        markdown += "\n"
    
    # Add summary of passes
    passes = issue_data.get('passes', [])
    if passes:
        markdown += f"**âœ… Passing Rules:** {len(passes)} rules passed\n\n"
    
    markdown += "---\n\n"
    
    return markdown


def parse_label_section(lines: List[str], start_idx: int) -> str:
    """Parse the label usage section"""
    label_markdown = ""
    
    # Look for summary statistics
    for i in range(start_idx, min(start_idx + 20, len(lines))):
        line = lines[i].strip()
        if line.startswith('Total unique labels:'):
            count = line.split(':')[1].strip()
            label_markdown += f"**ğŸ“Š Total Unique Labels:** {count}\n"
        elif line.startswith('Total label usages:'):
            count = line.split(':')[1].strip()
            label_markdown += f"**ğŸ·ï¸ Total Label Usages:** {count}\n"
        elif line.startswith('Average labels per issue:'):
            avg = line.split(':')[1].strip()
            label_markdown += f"**ğŸ“ˆ Average per Issue:** {avg}\n\n"
    
    label_markdown += "### ğŸ† Top Labels by Usage\n\n"
    
    # Parse individual labels (simplified for brevity)
    in_labels = False
    for i in range(start_idx, len(lines)):
        line = lines[i].strip()
        if '[LABELS] Label Details' in line:
            in_labels = True
            continue
        elif in_labels and re.match(r'^\d+\.\s+Label:', line):
            label_match = re.search(r"Label: '([^']+)' \(used (\d+) times\)", line)
            if label_match:
                label_name, usage_count = label_match.groups()
                label_markdown += f"- **`{label_name}`** - Used {usage_count} times\n"
        elif in_labels and line.startswith('[') and line.endswith(']'):
            break
    
    return label_markdown


def generate_summary_section(console_text: str) -> str:
    """Generate summary insights"""
    
    # Count issues by type
    story_count = console_text.count('[CHECK] CHECKING STORY ISSUES')
    task_count = len(re.findall(r'\d+\. Task: AP-\d+', console_text))
    bug_count = len(re.findall(r'\d+\. Bug: AP-\d+', console_text))
    epic_count = len(re.findall(r'\d+\. Epic: AP-\d+', console_text))
    
    # Count violations
    warning_count = console_text.count('[WARNING]')
    error_count = console_text.count('[ERROR]')
    critical_count = console_text.count('[CRITICAL]')
    
    summary = f"""### ğŸ“ˆ Issue Analysis Summary

| Issue Type | Count |
|------------|-------|
| ğŸ“– Stories | {story_count} |
| âœ… Tasks | {task_count} |
| ğŸ› Bugs | {bug_count} |
| ğŸ¯ Epics | {epic_count} |

### âš ï¸ Rule Violations Summary

| Severity | Count |
|----------|-------|
| ğŸ”´ Critical | {critical_count} |
| ğŸŸ  Error | {error_count} |
| ğŸŸ¡ Warning | {warning_count} |

### ğŸ’¡ Key Insights

- **Most Common Issue:** Tasks ({task_count} issues analyzed)
- **Data Quality:** {'Good' if warning_count < 50 else 'Needs Improvement' if warning_count < 100 else 'Poor'}
- **Top Areas for Improvement:**
  - Assignment and ownership clarity
  - Description completeness  
  - Issue linking and relationships

"""
    
    return summary


def main():
    """Convert report.txt to enhanced markdown format"""
    
    input_file = "report.txt"
    output_file = "report_enhanced.md"
    
    try:
        print(f"ğŸ“– Reading report from: {input_file}")
        with open(input_file, 'r', encoding='utf-8', errors='replace') as f:
            console_content = f.read()
        
        print(f"ğŸ”„ Creating enhanced markdown report...")
        
        # Convert to enhanced markdown
        markdown_content = create_enhanced_markdown_report(console_content)
        
        # Write the enhanced markdown report
        print(f"ğŸ’¾ Writing enhanced report to: {output_file}")
        with open(output_file, 'w', encoding='utf-8') as f:
            f.write(markdown_content)
        
        print(f"âœ… Successfully created enhanced markdown report!")
        print(f"ğŸ“„ Input: {input_file}")
        print(f"ğŸ“ Output: {output_file}")
        
        # Show file sizes
        import os
        input_size = os.path.getsize(input_file) if os.path.exists(input_file) else 0
        output_size = os.path.getsize(output_file) if os.path.exists(output_file) else 0
        print(f"ğŸ“Š Input size: {input_size:,} bytes")
        print(f"ğŸ“Š Output size: {output_size:,} bytes")
        
    except FileNotFoundError:
        print(f"âŒ Error: Could not find input file: {input_file}")
        print(f"Make sure the report file exists and try again.")
    except Exception as e:
        print(f"âŒ Error creating enhanced report: {e}")


if __name__ == "__main__":
    main()